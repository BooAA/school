(defparameter *initial-line-number* 0)
(defvar *line-number* *initial-line-number*)

(defparameter *initial-symbol-table* (make-hash-table :test #'equal))
(setf (gethash "R0"     *initial-symbol-table*) 0)
(setf (gethash "R1"     *initial-symbol-table*) 1)
(setf (gethash "R2"     *initial-symbol-table*) 2)
(setf (gethash "R3"     *initial-symbol-table*) 3)
(setf (gethash "R4"     *initial-symbol-table*) 4)
(setf (gethash "R5"     *initial-symbol-table*) 5)
(setf (gethash "R6"     *initial-symbol-table*) 6)
(setf (gethash "R7"     *initial-symbol-table*) 7)
(setf (gethash "R8"     *initial-symbol-table*) 8)
(setf (gethash "R9"     *initial-symbol-table*) 9)
(setf (gethash "R10"    *initial-symbol-table*) 10)
(setf (gethash "R11"    *initial-symbol-table*) 11)
(setf (gethash "R12"    *initial-symbol-table*) 12)
(setf (gethash "R13"    *initial-symbol-table*) 13)
(setf (gethash "R14"    *initial-symbol-table*) 14)
(setf (gethash "R15"    *initial-symbol-table*) 15)
(setf (gethash "SCREEN" *initial-symbol-table*) 16384)
(setf (gethash "KBD"    *initial-symbol-table*) 24576)
(setf (gethash "SP"     *initial-symbol-table*) 0)
(setf (gethash "LCL"    *initial-symbol-table*) 1)
(setf (gethash "ARG"    *initial-symbol-table*) 2)
(setf (gethash "THIS"   *initial-symbol-table*) 3)
(setf (gethash "THAT"   *initial-symbol-table*) 4)
(defvar *symbol-table* *initial-symbol-table*)

(defun labelp (code)
  (and (char= (char code 0) #\()
       (char= (char code (1- (length code))) #\))))

(defun parse (line)
  (let ((comment-pos (search "//" line)))
    (remove #\Space (subseq line 0 comment-pos))))

(defun mark-label (code)
  (let ((label (subseq code 1 (1- (length code)))))
    (setf (gethash label *symbol-table*) *line-number*)))

(defun phase-1 (filename)
  (setf *line-number* *initial-line-number*)
  (setf *symbol-table* *initial-symbol-table*)
  (with-open-file (stream filename)
    (let ((translation-queue nil))
      (do ((line (read-line stream nil) (read-line stream nil)))
          ((null line))
        (setf line (string-right-trim '(#\Return) line))
        (let ((code (parse line)))
          (unless (= (length code) 0)
            (cond ((labelp code) (mark-label code))
                  (t (push code translation-queue)
                     (setf *line-number* (1+ *line-number*)))))))
      (reverse translation-queue))))

;;;;;;;;;;;;;;;;;;;;;;;;;;  phase 1 ends here ;;;;;;;;;;;;;;;;;;;;;;;;;

(defparameter *dest-code-table* (make-hash-table :test #'equal))
(setf (gethash ""    *dest-code-table*) "000")
(setf (gethash "M"   *dest-code-table*) "001")
(setf (gethash "D"   *dest-code-table*) "010")
(setf (gethash "MD"  *dest-code-table*) "011")
(setf (gethash "A"   *dest-code-table*) "100")
(setf (gethash "AM"  *dest-code-table*) "101")
(setf (gethash "AD"  *dest-code-table*) "110")
(setf (gethash "AMD" *dest-code-table*) "111")

(defparameter *jump-code-table* (make-hash-table :test #'equal))
(setf (gethash ""    *jump-code-table*) "000")
(setf (gethash "JGT" *jump-code-table*) "001")
(setf (gethash "JEQ" *jump-code-table*) "010")
(setf (gethash "JGE" *jump-code-table*) "011")
(setf (gethash "JLT" *jump-code-table*) "100")
(setf (gethash "JNE" *jump-code-table*) "101")
(setf (gethash "JLE" *jump-code-table*) "110")
(setf (gethash "JMP" *jump-code-table*) "111")

(defparameter *comp-code-table* (make-hash-table :test #'equal))
(setf (gethash "0"   *comp-code-table*) "0101010")
(setf (gethash "1"   *comp-code-table*) "0111111")
(setf (gethash "-1"  *comp-code-table*) "0111010")
(setf (gethash "D"   *comp-code-table*) "0001100")
(setf (gethash "A"   *comp-code-table*) "0110000")
(setf (gethash "!D"  *comp-code-table*) "0001101")
(setf (gethash "!A"  *comp-code-table*) "0110001")
(setf (gethash "-D"  *comp-code-table*) "0001111")
(setf (gethash "-A"  *comp-code-table*) "0110011")
(setf (gethash "D+1" *comp-code-table*) "0011111")
(setf (gethash "A+1" *comp-code-table*) "0110111")
(setf (gethash "D-1" *comp-code-table*) "0001110")
(setf (gethash "A-1" *comp-code-table*) "0110010")
(setf (gethash "D+A" *comp-code-table*) "0000010")
(setf (gethash "D-A" *comp-code-table*) "0010011")
(setf (gethash "A-D" *comp-code-table*) "0000111")
(setf (gethash "D&A" *comp-code-table*) "0000000")
(setf (gethash "D|A" *comp-code-table*) "0010101")
(setf (gethash "M"   *comp-code-table*) "1110000")
(setf (gethash "!M"  *comp-code-table*) "1110001")
(setf (gethash "M+1" *comp-code-table*) "1110111")
(setf (gethash "M-1" *comp-code-table*) "1110010")
(setf (gethash "D+M" *comp-code-table*) "1000010")
(setf (gethash "D-M" *comp-code-table*) "1010011")
(setf (gethash "M-D" *comp-code-table*) "1000111")
(setf (gethash "D&M" *comp-code-table*) "1000000")
(setf (gethash "D|M" *comp-code-table*) "1010101")

(defparameter *initial-variable-sp* 16)
(defvar *variable-sp* *initial-variable-sp*)

(defun lookup-symbol (var)
  (multiple-value-bind (value exist-p) (gethash var *symbol-table*)
    (if exist-p
        value
        (progn
          (setf (gethash var *symbol-table*) *variable-sp*)
          (setf *variable-sp* (1+ *variable-sp*))
          (1- *variable-sp*)))))

(defun A-instruciton-p (code)
  (char= (char code 0) #\@))

(defun codegen-A-instruction (code)
  (let ((body (subseq code 1)))
    (if (digit-char-p (char body 0))
        (format nil "0~15,'0b" (parse-integer body))
        (format nil "0~15,'0b" (lookup-symbol body)))))

(defun codegen-C-instruction (code)
  (let* ((l (length code))
         (equal-pos (or (search "=" code) 0))
         (colon-pos (or (search ";" code) l))
         (dest (subseq code 0 equal-pos))
         (comp (subseq code (if (= equal-pos 0) 0 (1+ equal-pos)) colon-pos))
         (jump (subseq code (if (= colon-pos l) l (1+ colon-pos)))))
    (format nil "111~a~a~a" (gethash comp *comp-code-table*)
                            (gethash dest *dest-code-table*)
                            (gethash jump *jump-code-table*))))

(defun phase-2 (translation-queue)
  (setf *variable-sp* *initial-variable-sp*)
  (let ((binary-code nil))
    (dolist (code translation-queue)
      (if (A-instruciton-p code)
          (push (codegen-A-instruction code) binary-code)
          (push (codegen-C-instruction code) binary-code)))
    (reverse binary-code)))

(defun assembler (filename)
  (with-open-file (stream
                   (make-pathname :type "hack" :defaults filename)
                   :direction :output
                   :if-exists :supersede)
    (let* ((translation-queue (phase-1 filename))
           (binary-code       (phase-2 translation-queue)))
      (dolist (code binary-code)
        (format stream "~a~%" code)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;  phase 2 ends here ;;;;;;;;;;;;;;;;;;;;;;;;;
